#include "Main.h"

BOOL GetMBR(HANDLE hDevice, unsigned char* buf, DWORD ReadSize) {
	if (hDevice == NULL)
		return FALSE;
	else
	{
		DWORD Read;
		SetFilePointer(hDevice, 0, NULL, NULL);
		return ReadFile(hDevice, buf, ReadSize, &Read, NULL);
	}
}

UINT64 GetPartitionSize(TEXT* pcPart)
{
	HANDLE hDevice;
	BOOL bResult;
	DWORD junk;

	hDevice = CreateFile(pcPart, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

	if (hDevice == INVALID_HANDLE_VALUE) // cannot open the drive
	{
		return 0;
	}

	GET_LENGTH_INFORMATION pdg;
	bResult = DeviceIoControl(hDevice,  // device to be queried
		IOCTL_DISK_GET_LENGTH_INFO,  // operation to perform
		NULL, 0, // no input buffer
		&pdg, sizeof(pdg),     // output buffer
		&junk,                 // # bytes returned
		(LPOVERLAPPED)NULL);  // synchronous I/O

	CloseHandle(hDevice);

	return (UINT64)pdg.Length.QuadPart;
}

UINT64 GetPartitionSize(HANDLE hDevice)
{
	BOOL bResult;
	DWORD junk;

	if (hDevice == INVALID_HANDLE_VALUE) // cannot open the drive
	{
		return 0;
	}

	GET_LENGTH_INFORMATION pdg;
	bResult = DeviceIoControl(hDevice,  // device to be queried
		IOCTL_DISK_GET_LENGTH_INFO,  // operation to perform
		NULL, 0, // no input buffer
		&pdg, sizeof(pdg),     // output buffer
		&junk,                 // # bytes returned
		(LPOVERLAPPED)NULL);  // synchronous I/O

	return (UINT64)pdg.Length.QuadPart;
}

unsigned long HextoDec(const unsigned char* hex, int length)
{
	int i;
	unsigned long rslt = 0;
	for (i = 0; i < length; i++)
	{
		rslt += (unsigned long)(hex[i]) << (8 * (length - 1 - i));
	}
	return rslt;
}

BOOL GetPBRTarget(HANDLE hDisk, PPBR pPBR) {
	unsigned int DiskCount = 0;
	DWORD DiskInfo = GetLogicalDrives(); //获取系统中逻辑驱动器的数量，函数返回的是一个32位无符号整型数据。
	while (DiskInfo)//通过循环操作查看每一位数据是否为1，如果为1则磁盘为真,如果为0则磁盘不存在。
	{
		if (DiskInfo & 1)//通过位运算的逻辑与操作，判断是否为1
		{
			++DiskCount;
		}
		DiskInfo = DiskInfo >> 1;//通过位运算的右移操作保证每循环一次所检查的位置向右移动一位。
	}

	ZeroMemory(pPBR, sizeof(*pPBR));
	if (hDisk == NULL)
	{
		return FALSE;
	}
	if (DiskCount == 0)
	{
		return FALSE;
	}
	pPBR->Datas = new PBR_DATA[DiskCount];

	unsigned char MBR[MBR_SIZE]{ 0 };
	unsigned char PBRTarget[4][7]{ 0 };
	UINT64 PBRStart[4]{ 0 };
	GetMBR(hDisk, MBR, MBR_SIZE);

	EOP Size;
	for (unsigned int n = 0; n < 4; n++)
	{
		for (int i = 0; i < 4; i++)
		{
			Size.Part[n].c[i] = MBR[457 + 16 * n - i];
			Size.Part[n].l = HextoDec(Size.Part[n].c, sizeof(Size.Part[n].c));
		}
	}
	UINT64 Min = -1;
	for (unsigned int i = 0; i < 4; i++)
	{
		if (Size.Part[i].l != 0)
		{
			if (Size.Part[i].l < Min)
			{
				Min = Size.Part[i].l;
			}
		}
	}
	pPBR->StartPBRSector = Min;

	pPBR->PartitionCount = DiskCount;
	pPBR->Datas[0].PointerToPBRSector = pPBR->StartPBRSector;

	wTEXT Volume[MAX_PATH];
	wTEXT FullName[7];
	wTEXT Temp[MAX_PATH];
	wTEXT DeviceName[MAX_PATH];
	DISK_GEOMETRY pdg = { 0 };
	HANDLE hFindHandle = FindFirstVolume(Volume, MAX_PATH);
	DWORD Junk;
	GetVolumePathNamesForVolumeName(Volume, Temp, sizeof(Temp), &Junk);

	FullName[0] = '\\';
	FullName[1] = '\\';
	FullName[2] = '.';
	FullName[3] = '\\';
	FullName[4] = Temp[0];
	FullName[5] = ':';
	FullName[6] = 0;

	ZeroMemory(Temp, sizeof(Temp));
	Temp[0] = FullName[4];
	Temp[1] = FullName[5];
	Temp[2] = 0;
	QueryDosDevice(Temp, DeviceName, sizeof(DeviceName));
	memcpy(pPBR->Datas[0].FullPath, FullName, 7);

	for (unsigned int i = 1; i < DiskCount; i++)
	{
		if (!FindNextVolume(hFindHandle, Volume, MAX_PATH))
			break;

		GetVolumePathNamesForVolumeName(Volume, Temp, sizeof(Temp), &Junk);

		FullName[0] = '\\';
		FullName[1] = '\\';
		FullName[2] = '.';
		FullName[3] = '\\';
		FullName[4] = Temp[0];
		FullName[5] = ':';
		FullName[6] = 0;

		ZeroMemory(Temp, sizeof(Temp));
		Temp[0] = FullName[4];
		Temp[1] = FullName[5];
		Temp[2] = 0;
		QueryDosDevice(Temp, DeviceName, sizeof(DeviceName));

		memcpy(pPBR->Datas[i].FullPath, FullName, 7);
		UINT64 TempValue = GetPartitionSize(FullName);
		if (TempValue != GetPartitionSize(hDisk))
		{
			pPBR->Datas[i].PointerToPBRSector = ((GetPartitionSize(pPBR->Datas[i - 1].FullPath) / 512) + pPBR->Datas[i - 1].PointerToPBRSector);
		}
		else
		{
			pPBR->Datas[i].PointerToPBRSector = -1;
		}
	}
	FindVolumeClose(hFindHandle);

	return TRUE;
}

BOOL GetSectorEx(HANDLE hDevice, unsigned char* buf, DWORD ReadSize, UINT64 ALL) {
	if (hDevice == NULL)
		return FALSE;
	else
	{
		DWORD Read;
		LARGE_INTEGER li{ 0 };
		li.QuadPart = ALL * 512;
		SetFilePointerEx(hDevice, li, NULL, FILE_BEGIN);
		return ReadFile(hDevice, buf, ReadSize, &Read, NULL);
	}
}

BOOL QueryDiskPBR(TEXT* PhyName, PPBR pPBR) {
	for (unsigned int i = 0; i < pPBR->PartitionCount; i++)
	{
		HANDLE hPartition = CreateFile(PhyName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
		GetSectorEx(hPartition, pPBR->Datas[i].PointerToPBRSectorData, SECTOR_SIZE, pPBR->Datas[i].PointerToPBRSector);
	}
	return GetLastError();
}

BOOL DestroyDiskPBR(
	int					iPhysicaldirve,
	unsigned long long	iPoint = 8
)
{
	LARGE_INTEGER li = { 0 };
	li.QuadPart = iPoint;
	const BYTE EmptyPBR[512] = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	};

	DWORD dwReadSize;
	TEXT cName[MAX_PATH] = _T("\\\\.\\PHYSICALDRIVE");
	wTEXT buf[MAX_PATH];
	swprintf_s(buf, MAX_PATH, _T("%s%d"), cName, iPhysicaldirve);
	HANDLE hFile = CreateFile(buf, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);

	if (hFile == INVALID_HANDLE_VALUE)
	{
		return FALSE;
	}
	if (INVALID_SET_FILE_POINTER == SetFilePointer(hFile, li.LowPart, &li.HighPart, NULL))
	{
		CloseHandle(hFile);
		return FALSE;
	}
	if (WriteFile(hFile, EmptyPBR, 512, &dwReadSize, NULL) == 0)
	{
		CloseHandle(hFile);
		return FALSE;
	}
	if (CloseHandle(hFile) == FALSE)
	{
		return FALSE;
		return FALSE;
	}
	return TRUE;
}

BOOL ReturnSectorEx(HANDLE hDevice, unsigned char* buf, DWORD WriteSize, UINT64 ALL) {
	if (hDevice == NULL)
		return FALSE;
	else
	{
		DWORD Read;
		LARGE_INTEGER li{ 0 };
		li.QuadPart = ALL * 512;
		SetFilePointerEx(hDevice, li, NULL, FILE_BEGIN);
		return WriteFile(hDevice, buf, WriteSize, &Read, NULL);
	}
}

ThreadFunction(PBRProtector)
{
	int* PhyNum = (int*)lpParam;
	wTEXT PhyName[MAX_PATH];
	unsigned char NPBR[SECTOR_SIZE];
	swprintf_s(PhyName, MAX_PATH, _T("\\\\.\\PHYSICALDRIVE%d"), *PhyNum);
	PPBR pPBR = new PBR;
	HANDLE hDisk = CreateFile(PhyName, GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, 0);
	GetPBRTarget(hDisk, pPBR);
	QueryDiskPBR(PhyName, pPBR);
	while (true)
	{
		GetSectorEx(hDisk, NPBR, SECTOR_SIZE, pPBR->Datas[*PhyNum].PointerToPBRSector);
		cout << pPBR->Datas[*PhyNum].PointerToPBRSector << endl;
		if (memcpy(NPBR, pPBR->Datas[*PhyNum].PointerToPBRSectorData, SECTOR_SIZE))
		{
			ReturnSectorEx(hDisk, pPBR->Datas[*PhyNum].PointerToPBRSectorData, SECTOR_SIZE, pPBR->Datas[*PhyNum].PointerToPBRSector);
			Sleep(1);
		}
	}
}